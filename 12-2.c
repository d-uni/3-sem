/*Программа должна напечатать на стандартный поток вывода свой pid.

Затем программе на стандартном потоке ввода подаются 32-битные знаковые целые числа. В зависимости от текущего режима работы введенное число либо прибавляется к текущему накопленному значению, либо умножается на текущее накопленное значение. После этого новое накопленное значение выводится на стандартный поток вывода. Переполнение при выполнении 32-битных операций должно игнорироваться, то есть сохранять младшие 32 бита результата, но не приводить к UB. Программа начинает работу в режиме сложения. Начальное накопленное значение равно 0.

При получении сигнала SIGINT программа переключается в режим сложения. При получении сигнала SIGQUIT программа переключается в режим умножения.

Стандартный ввод и стандартный вывод программы будут перенаправлены. Не забывайте сбрасывать буфер вывода. С другой стороны каналов находится другой процесс, который начнет свою работу как только получит pid процесса. Можете расчитывать, что сигналы обрабатываются по модели BSD.

Пример дан в предположении, что программе не отправляются сигналы.
Examples
Input

100 200 -44 500

Output

100
300
256
756*/

#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <fcntl.h>
#include <signal.h>
volatile sig_atomic_t flug = 1;
void fun(int sig) {
    signal(SIGINT, fun);
    signal(SIGQUIT, fun);
    if(sig == SIGINT) {
        flug = 1;
    } else if(sig == SIGQUIT) {
        flug = 0;
    }
}
int
main(void)
{
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);
    signal(SIGINT, fun);
    signal(SIGQUIT, fun);
    long long int out = 0;
    int x;
    printf("%d\n", getpid());
    while((scanf("%d", &x)) > 0) {
        if(flug == 1) {
            out = out + x;
        } else if(flug == 0) {
            out = out * x;
        }
        printf("%d\n", (int)out);
        out = (int)out;
    }
    return 0;
}
