/*  Программе в аргументах командной строки задаются:

    Количество процессов (nproc) (1 <= nproc <= 400);
    Ключ IPC (key);
    Максимальное значение (maxval) (32-битное знаковое целое положительное значение).

Программа должна создать nproc процессов и запустить между ними пересылку числа. Процессы нумеруются от 1 до nproc. Процесс-родитель имеет номер 0. Каждый процесс получает число, печатает свой порядковый номер, значение числа, и номер процесса-отправителя как показано в примере. Затем процесс увеличивает его на 1 и пересылает число процессу с номером (val * val * val * val) % nproc + 1, где val – значение числа после увеличения. Если значение числа после увеличения стало больше maxval, процесс не пересылает число следующему, а (совместно с родителем) выполняет действия по завершению игры. Игра начинается с первого из созданных процессов со значения 0. Отец дожидается завершения всех процессов и сам завершает работу.

Обратите внимание, при достижении максимального значения оно печатается, но не пересылается дальше.

Можете использовать следующие варианты создания процессов и синхронизации:

    Процессы, SysV семафоры (sys/sem), SysV разделяемая память (sys/shm).
    Процессы, SysV семафоры, mmap.
    Процессы, eventfd, mmap.
    Процессы, POSIX semaphore, mmap.
    Нити, mutex, condvar.

Второй аргумент командной строки не используется, если программа не использует SysV IPC.

Другие варианты использовать запрещено.

Объекты, созданные для работы программы, например, массив семафоров, должны быть уничтожены.

Тестирование завершается с вердиктом 'Synchronization error', если процесс-отец (то есть ваша программа, запускаемая на тестирование) заканчивает работу раньше какого-либо из своих потомков.

Тестирование завершается с вердиктом 'Security violation', если после завершения работы вашей программы остались неудаленные объекты IPC.
Examples
Input

Output

1 0 0
2 1 1
1 2 2
2 3 1
1 4 2*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/wait.h>
#include <unistd.h>
int main(int argc, char *argv[])
{
    long long int nproc = atoll(argv[1]), key = atoll(argv[2]), maxval = atoll(argv[3]);
    int semid = semget(key, nproc + 1, 0600 | IPC_CREAT);
    int *pmem = NULL;
    int shmid = shmget(key, 2 * sizeof(*pmem), 0600 | IPC_CREAT);
    pmem = shmat(shmid, NULL, 0);
    *pmem = 0;
    *(pmem + 1) = 0;
    for (int i = 1; i < nproc + 1; i++) {
        if(!(fork())) {
            while(semop(semid, (struct sembuf[]) {{i, -1, 0 }}, 1) >= 0) {
                printf("%d %d %d\n", i, (*pmem)++, pmem[1]);
                fflush(stdout);
                *(pmem + 1) = i;
                if(*pmem > maxval) {
                    semctl(semid, 0 , IPC_RMID);
                    shmctl(shmid, IPC_RMID, NULL);
                    break;
                }
                semop(semid, (struct sembuf[])
                {{((*pmem%nproc)*(*pmem%nproc)*(*pmem%nproc)*(*pmem%nproc))%nproc+1, 1, 0}},
                    1);
            }
            exit(0);
        }

    }
    semop(semid, (struct sembuf[]) {{1,1,0}}, 1);
    while (wait(NULL) >= 0);
    return 0;
}
